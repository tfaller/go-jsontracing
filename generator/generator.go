package generator

import (
	"errors"
	"fmt"
	"io"
	"reflect"
)

// ErrAlreadyGenerated indicates that the generator already run
var ErrAlreadyGenerated = errors.New("the generator was already executed")

// ErrNoTypesToGenerate indicates that no types was added to the generator.
var ErrNoTypesToGenerate = errors.New("no types were added to the generator")

// Generator generates types to auto-trace usage of JSON properties.
type Generator struct {
	doneTypes      map[reflect.Type]struct{}
	remainingTypes []reflect.Type
	done           bool
	out            io.Writer
	pkg            string
}

// NewGenerator generates a new generator
func NewGenerator(out io.Writer, packageName string) *Generator {
	return &Generator{
		doneTypes:      map[reflect.Type]struct{}{},
		remainingTypes: []reflect.Type{},
		out:            out,
		pkg:            packageName,
	}
}

// AddType adds an type that should be traced
func (g *Generator) AddType(t reflect.Type) {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	if _, done := g.doneTypes[t]; done {
		return
	}
	g.doneTypes[t] = struct{}{}
	g.remainingTypes = append(g.remainingTypes, t)
}

// Generate generates the code for types to auto trace json properties
func (g *Generator) Generate() error {
	if g.done {
		return ErrAlreadyGenerated
	}

	if len(g.remainingTypes) == 0 {
		return ErrNoTypesToGenerate
	}

	g.out.Write(fileHeader)
	g.out.Write([]byte(fmt.Sprintf("package %v\n", g.pkg)))
	g.out.Write(staticImports)

	for {
		l := len(g.remainingTypes)
		if l == 0 {
			break
		}

		t := g.remainingTypes[l-1]
		g.remainingTypes = g.remainingTypes[:l-1]

		switch t.Kind() {

		case reflect.Struct:
			err := writeStruct(t, g)
			if err != nil {
				return err
			}

		case reflect.Slice:
			err := writeSlice(t, g)
			if err != nil {
				return err
			}

		case reflect.Map:
			err := writeMap(t, g)
			if err != nil {
				return err
			}

		case reflect.Interface:
			g.out.Write([]byte(newInterfaceCode))
			// add implicit types
			g.AddType(reflect.TypeOf((*[]interface{})(nil)))
			g.AddType(reflect.TypeOf((*map[string]interface{})(nil)))

		case reflect.Bool, reflect.String,
			reflect.Float32, reflect.Float64,
			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			// noting to to ... these are primitive types, can't be further traced

		default:
			return fmt.Errorf("Unsupported type: %v", t)
		}
	}
	return nil
}

// newInterfaceCode is simple glue code
// to make tracing of generic json elements possible
const newInterfaceCode = `
// NewInterface takes a generic json value and builds a tracer
func NewInterface(i interface{}, t jsontracing.Tracer) interface{} {
	switch i.(type) {

	case float64, bool, string:
		return i

	case map[string]interface{}:
		v := i.(map[string]interface{})
		return NewMapInterface(&v, t)

	case []interface{}:
		v := i.([]interface{})
		return NewSliceInterface(&v, t)
	}

	panic("a real json has only float64, bool, string, []interface, map[string]interface{} values")
}
`

var fileHeader = []byte("// DO NOT EDIT - file was generated by go-jsontracing\n\n")

var staticImports = []byte(`
import (
	"fmt"

	"github.com/tfaller/go-jsontracing"
)

// prevent unused import error if this file does not need it.
var _ = fmt.Sprintf
`)
